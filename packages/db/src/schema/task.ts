import {
  boolean,
  date,
  integer,
  jsonb,
  pgEnum,
  pgTable,
  text,
  time,
  timestamp,
  uuid,
} from "drizzle-orm/pg-core";
import {
  createInsertSchema,
  createSelectSchema,
  createUpdateSchema,
} from "drizzle-zod";
import z from "zod";
import { user } from "./auth";

// ============================================================================
// RECURRENCE SCHEMA (Zod discriminated union for JSONB column)
// ============================================================================

const dailyRecurrence = z.object({
  freq: z.literal("DAILY"),
  interval: z.number().int().positive().default(1),
});

const weeklyRecurrence = z.object({
  freq: z.literal("WEEKLY"),
  interval: z.number().int().positive().default(1),
  byDay: z.array(z.enum(["MO", "TU", "WE", "TH", "FR", "SA", "SU"])).min(1),
});

const monthlyRecurrence = z.object({
  freq: z.literal("MONTHLY"),
  interval: z.number().int().positive().default(1),
  byMonthDay: z.number().int().min(1).max(31),
});

const yearlyRecurrence = z.object({
  freq: z.literal("YEARLY"),
  interval: z.number().int().positive().default(1),
});

const baseRecurrence = z.discriminatedUnion("freq", [
  dailyRecurrence,
  weeklyRecurrence,
  monthlyRecurrence,
  yearlyRecurrence,
]);

const recurrenceEndOptions = z
  .object({
    until: z.string().optional(), // ISO date string "2025-12-31"
    count: z.number().int().positive().max(1000).optional(), // End after N occurrences
  })
  .partial();

/** Task recurrence pattern - discriminated union by frequency type */
export const taskRecurrenceSchema = z.intersection(
  baseRecurrence,
  recurrenceEndOptions
);

export type TaskRecurrence = z.infer<typeof taskRecurrenceSchema>;

export const taskStatusEnum = pgEnum("task_status", [
  "todo",
  "in_progress",
  "done",
]);

export const taskTable = pgTable("task", {
  id: uuid("id").primaryKey(), // UUIDv7 generated by application
  userId: text("user_id")
    .notNull()
    .references(() => user.id, { onDelete: "cascade" }),
  title: text("title").notNull(),
  description: text("description"),
  status: taskStatusEnum("status").default("todo").notNull(),
  /** Due date (calendar date only, no time) - when task is due */
  dueDate: date("due_date", { mode: "string" }),
  /** Start date (calendar date) - when task appears in inbox or on calendar */
  startDate: date("start_date", { mode: "string" }),
  /** Start time (time of day only, HH:mm:ss) - combined with startDate for calendar scheduling */
  startTime: time("start_time"),
  durationMinutes: integer("duration_minutes").notNull().default(30),

  // Recurrence fields
  /** Points to the master task of the series. null=non-recurring, self=master, other=occurrence */
  seriesMasterId: uuid("series_master_id"),
  /** Recurrence pattern (stored on master only). JSONB discriminated union by freq. */
  recurrence: jsonb("recurrence").$type<TaskRecurrence | null>(),
  /** True if this occurrence was individually edited (protected during series regeneration) */
  isException: boolean("is_exception").default(false).notNull(),

  createdAt: timestamp("created_at", { mode: "string" }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { mode: "string" })
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date().toISOString()),
});

export const taskSelectSchema = createSelectSchema(taskTable).safeExtend({
  recurrence: taskRecurrenceSchema.nullable(),
});

export const taskInsertSchema = createInsertSchema(taskTable)
  .safeExtend({
    recurrence: taskRecurrenceSchema.nullable().optional(),
  })
  .omit({
    id: true,
  });

export const taskUpdateSchema = createUpdateSchema(taskTable).safeExtend({
  recurrence: taskRecurrenceSchema.nullable().optional(),
});

export type TaskSelect = typeof taskTable.$inferSelect;
export type TaskInsert = Omit<typeof taskTable.$inferInsert, "id">;
export type TaskUpdate = z.infer<typeof taskUpdateSchema>;
